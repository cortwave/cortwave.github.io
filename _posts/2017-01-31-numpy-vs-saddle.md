---
layout: post
title: "Numpy vs Saddle"
description: "Статья с целью изучить базовые инструменты для работы с данными для Scala"
category: data
tags: ['data', 'scala', 'python', 'saddle', 'numpy']
---
{% include JB/setup %}

В последнее время меня заинтересовала тема машинного обучения. Немного покопавшись в тематических ресурсах, можно понять, что самым очевидным выбором ЯП для продвижения в данной сфере будут являться [python](https://www.python.org/) или [R](https://www.r-project.org/) (такой вариант как [Julia](http://julialang.org/) я сразу отбросил, так как, по сравнению с R или python, материалов по нему куда меньше, что не очень хорошо на первых парах). Опыт с питоном у меня практически отсутствует (пару раз приходилось разбираться в уже написанном коде). C R дела обстоят немного лучше, на 3-ем курсе университета я выполнял с помощью этого языка задания по курсу 'Анализ Данных'. В целом, впечатления о нем остались скорее положительные, чем отрицательные: огромное количество различных пакетов (из которых я использовал 2-3 от силы), большие возможности для визуализации, лаконичный синтаксис. Тем не менее R казался, да и до сих пор кажется мне более теоритическим языком. В плане того, что на нем очень легко визуализировать данные, применять алгоритмы из различных пакетов, оформлять [эффектные ноутбуки](http://rmarkdown.rstudio.com/r_notebooks.html), но когда дело доходит до интеграции этих алгоритмов в приложение (например, веб), то появляется сразу куча вопросов. Как прикрутить http-сервер к питону не возникает никаких сомнений. Для R существуют [решения](https://github.com/yihui/servr), но так как язык изначально позиционирует себя, как язык для работы с данными, то перспектива писать на нем http-сервер кажется не очень привлекательной.

Таким образом, на первый взгляд, питон кажется очевидным выбором. Легкий синтаксис, огромное количество инструментов, универсальность. Редко встретишь вакансию data scientist, где не требуется знание питона. Тем не менее у меня остаются небольшие сомнения. Сомнения в виде языка [Scala](https://www.scala-lang.org/). Опыт со scala у меня куда больше, чем с питоном и R вместе взятыми. Также плюсом является возможность продолжить писать в удобной ламповой IDE, есть опыт работы с интсрументами профилирования JVM. Тем более при работе со [спарком](http://spark.apache.org/) scala зарекомендовала себя как отличный язык для работы с данными. А spark, как известно, семимильными шагами покоряет мир. [Mllib](http://spark.apache.org/) имеет неплохой набор алгоритмов машинного обучения. На основании вышеописанных плюсов, scala кажется довольно привлекательным кандидатом для работы с машинным обучением. Сомнения вызывает только объем инструментария для анализа данных, который существует для Scala. Для python это и [numpy](http://www.numpy.org/), и [pandas](http://pandas.pydata.org/), и более серьезные вещи, как [tensorflow](https://github.com/tensorflow/tensorflow)(кстати, в релизе 1.0.0 объявлена поддержка эксперментального Java API), интерактивные ноутбуки, огромное количество средств визуализации. Остается посмотреть, чем на это сможет ответить scala. Возможно, scala и не имеет такой большой арсенал инструментов для работы с данными, но в каждой категории (обработка, визуализация, ноутбуки) да найдется аналог для этого языка. 

Таким образом я поставил перед собой задачу выяснить, насколько язык scala пригоден для data science. В данной статье я хочу начать с базового инструмента для работы с многомерными массивами, так как при работе с данными от этого никуда не убежишь. При непродолжительном поиске на глаза мне попалась библиотека [Saddle](http://saddle.github.io/). Авторы позиционируют ее как инструмент для работы с одно-двух мерными массивами, которая работает с примитивами, что, по идее, должно обеспечить хорошую скорость работы. Пожалуй, ближе всего к Saddle в мире питона находится numpy. Ниже я приведу примеры типичных операций с N-мерными массивами. При написании кода я использовал [Jupyter](http://jupyter.org/) ноутбук с установленным [scala-kernel](https://github.com/alexarchambault/jupyter-scala)(в результате чего даже проникся идеей ноутбуков, и они уже кажутся куда более привлекательной средой для быстрого прототипирования, чем IDE).

- создать вектор со значениями [10;59)

numpy

```python
np.arange(10,50)
````

saddle

```scala
Vec(10 until 50: _*)
```

в целом данный пример демонстрирует синтаксис создания вектора, ничего сожного, разве что на скале пример смотрится немного уродливее за счет необходимости преобразования Range -> vararg

- создание единичной матрицы 3х3

numpy

```python
np.eye(3)
```

saddle

```scala
mat.ident(3)
```
- создание трехмерного массива 3x3x3

numpy

```python
np.random.random((3,3,3))
```

saddle, к сожалению, не поддерживает работу с массивами размерности более двух

- сортировка массива

numpy

```python
Z = np.random.random(10)
Z.sort()
```

saddle

```scala
vec.rand(10).sorted
```

- заменить максимальное значение массива нулем

numpy

```python
Z = np.random.random(10)
Z[Z.argmax()] = 0
```

saddle

```scala
import org.saddle.array._
val v = vec.rand(10)
v(argmax(v)) = 0
```

- умножение матриц (a, b - матрицы)

numpy

```python
np.dot(a, b)
```

saddle

```scala
a dot b
```

- перестановка строк матрицы

numpy

```python
A = np.arange(25).reshape(5,5)
A[[0,1]] = A[[1,0]]
```

данной функции в saddle, увы, не нашел

- транспонирование

numpy

```python
np.transpose(A)
```

saddle

```scala
a.T
```

### Вывод

Saddle кажется неплохой библиотекой для решения определенного класса задач (работа с одно-двух мерными массивами). В целом без внимания осталась значительная часть библиотеки saddle: [series](http://saddle.github.io/doc/quickstart.html#series)(пары индекс-значение), [frames](http://saddle.github.io/doc/quickstart.html#frame) (аналог pandas-фреймов), [поддержка jodatime](http://saddle.github.io/doc/quickstart.html#dates-times-and-recurrences), I/o утилиты для работы с записью/чтением данных (которые, если верить [документации](http://saddle.github.io/doc/quickstart.html#i-o), нуждаются в серьезной доработке). В целом, я считаю, непраильно сравнивать saddle и numpy, так как numpy - узкоспециализированный инструмент для работы с многомерными массивами (но делающий это очень хорошо), когда saddle - библиотека, пытающаяся заменить сразу набор инструментов (numpy и pandas) и при этом сохранить идеологию scala-коллекций. Делать несложные вещи с помощью saddle легко и просто, но когда дело доходит до более сложных операций и структур, возникают проблемы. Проблемы решать тяжело, так как кроме документации на официальном сайте информации не найти.В свою очередь информации по numpy более чем достаточно и любая проблема быстро гуглится. Также смущает [github-репозиторий](https://github.com/saddle/saddle) Saddle. Последний релиз был 2 года назад, что ставит под сомнение развитие проекта в дальнейшем. В данном противостоянии уверенно побеждает numpy (несмотря на всю мою симпатию к scala). 

### P.S.

Уже после написания данной статьи мне на глаза попался более функциональный аналог numpy для scala - [breeze](https://github.com/scalanlp/breeze). Breeze является частью инструментария [scalanlp](http://www.scalanlp.org/)(набор инструментов для ml в целом и работы с естественными языками в частности). Судя по github-репозиторию, breeze имеет более активное сообщество разрабочиков. Но опять же не является узконаправленным инструментом. Breeze берет на себя задачи по работе с массивами, оптимизациями и даже визуализацией. В целом, данный подход мне не очень нравится. Инструментарий питона, где можно подобрать различные модули, каждый из которых будет выполнять свою роль, кажется более привлекательным в этом плане. Тем более breeze опять же не поддерживает работу с массивами размерностью более 2-ух. На основании моего небольшого погружения в мир анализа данных для scala и python и тех инструментов для каждого языка, с которыми мне довелось опзнакомиться, могу сделать вывод, что питон для сферы работы с данными мне кажется более привлекательным языком. Unix-подход библиотек, огромное сообщество, разнообразие инструментов намекают на необходимость изучения питона для дальнейшего продвежения в ML.
